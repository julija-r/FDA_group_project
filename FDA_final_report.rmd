---
title: "regression"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---


```{r setup, message=FALSE, warning=FALSE, results='hide'}
library(arrow)
library(ggplot2)
library(dplyr)
library(lubridate)
library(ggbreak)
library(fda)
library(fda.usc)
library(rainbow)
library(ftsa)
library(fdaoutlier)
library(readxl)
library(viridis)
library(knitr)
library(tidyr)
library(reshape2)
library(gridExtra)
library(refund)
library(refund.shiny)
```

#### Loading data
```{r, results='hide'}
set.seed(6558765)

consumption_data <- read_parquet("fda_duomenys.parquet")
consumption_data$Suvartojimo_laikotarpis <- as.Date(consumption_data$Suvartojimo_laikotarpis)

consumption_2024 <- consumption_data %>% filter(year(Suvartojimo_laikotarpis) == 2024)

population <- read_excel("savivaldybes_populiacija.xlsx")

consumption_by_population_2024 <- consumption_2024 %>%
  left_join(population, by = "Savivaldybe")
  
consumption_by_population_2024 <- consumption_by_population_2024 %>%
  mutate(kWh_per_person = Bendras_suvartojimas_mWh * 1000/ populiacija)
```

#### Smoothing
##### Cubic B-splines 
```{r, warning = FALSE}
# prepare data
consumption_by_population_2024$Suvartojimo_laikotarpis <- as.Date(consumption_by_population_2024$Suvartojimo_laikotarpis)
consumption_by_population_2024$Month <- as.numeric(format(consumption_by_population_2024$Suvartojimo_laikotarpis, "%m")) +
  12 * (as.numeric(format(consumption_by_population_2024$Suvartojimo_laikotarpis, "%Y")) - min(as.numeric(format(consumption_by_population_2024$Suvartojimo_laikotarpis, "%Y"))))

```

```{r}
# I found 6 to be optimal (not too smooth nor overfitting) maybe could be changed
num_basis <- 6
time_range <- range(consumption_by_population_2024$Month)
basis <- create.bspline.basis(time_range, nbasis = num_basis, norder = 4) # cubic splines
```

##### fd object for all municipalities
```{r}
energy_matrix <- consumption_by_population_2024 %>%
  dplyr::select(Savivaldybe, Month, kWh_per_person) %>%
  dplyr::arrange(Month, Savivaldybe) %>%  # ensure consistent order
  tidyr::pivot_wider(names_from = Savivaldybe, values_from = kWh_per_person) %>%
  dplyr::arrange(Month) %>%  # just to be safe
  dplyr::select(-Month) %>%
  as.matrix()


months <- sort(unique(consumption_by_population_2024$Month))

fd_obj_all_mun <- smooth.basis(argvals = months, y = energy_matrix, fdParobj = fdPar(basis, 2))$fd
# plot(fd_obj_all_mun)

```

```{r, warning = FALSE}
municipalities <- unique(consumption_by_population_2024$Savivaldybe)

smoothed_curves <- list()

for (municipality in municipalities) {
  subset <- consumption_by_population_2024 %>%
    filter(Savivaldybe == municipality) %>%
    arrange(Month)

  x <- subset$Month
  y <- subset$kWh_per_person

  # converting to functional data
  fd_obj <- smooth.basis(x, y, fdPar(basis, 2))$fd # second derivative smoothing


  smoothed_curves[[municipality]] <- data.frame(
    Month = seq(min(x), max(x), length.out = 100),
    Consumption = eval.fd(seq(min(x), max(x), length.out = 100), fd_obj),
    Savivaldybe = municipality
  )
}
```


```{r, warning = FALSE}
# combining smoothed results
smoothed_df <- bind_rows(smoothed_curves)
```



# Regression

### Preparing functional data (unemployment)

```{r}
# convert to wide format
smoothed_wide <- smoothed_df %>%
  pivot_wider(id_cols = Savivaldybe, 
              names_from = Month, 
              values_from = Consumption)

# create a matrix
consumption_matrix <- as.matrix(smoothed_wide[, -1])
rownames(consumption_matrix) <- municipalities

wages_ordered <- population %>%
  arrange(factor(Savivaldybe, levels = municipalities)) %>%
  pull(atlyginimas)

df <- data.frame(
  Savivaldybe = municipalities,
  ID = 1:length(municipalities),
  atlyginimas = as.numeric(wages_ordered)
)

df$consumption <- consumption_matrix

# convert to a refund object
consumption_df <- as_refundObj(df$consumption)

eval_points <- seq(min(months), max(months), length.out = 100)

consumption_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = 6, norder = 4) # cubic splines

consumption_fd <- Data2fd(eval_points, t(as.matrix(df$consumption)), consumption_basis)

# ggplot(consumption_df, aes(x = index, y = value, group = id)) +
#   geom_line()
```


```{r}
unemployment_2024 <- read.csv("nedarbas.csv")

matched_unemployment <- unemployment_2024 %>%
  filter(savivaldybe %in% df$Savivaldybe)

unemployment_matrix <- matched_unemployment %>%
  dplyr::select(savivaldybe, menesis, nedarbas) %>%
  dplyr::arrange(menesis, savivaldybe) %>%
  tidyr::pivot_wider(names_from = savivaldybe, values_from = nedarbas) %>%
  dplyr::arrange(menesis) %>%
  dplyr::select(-menesis) %>%
  as.matrix()

fd_obj_all_mun_unempl <- smooth.basis(argvals = months, y = unemployment_matrix, fdParobj = fdPar(basis, 2))$fd
plot(fd_obj_all_mun_unempl)

unemployment_smoothed <- eval.fd(eval_points, fd_obj_all_mun_unempl)

# transpose
unemployment_smoothed_t <- t(unemployment_smoothed)

df$unemployment <- unemployment_smoothed_t
colnames(df$unemployment) <- colnames(df$consumption)

```


### Preparing functional data (commercial/residential customer count per person)

```{r}
customer_types <- read_parquet("fda_sutart_kiekis.parquet")

customer_types$date <- as.Date(substr(customer_types$Suvartojimo_laikotarpis, 1, 10))

customer_types <- customer_types %>%
  filter(format(date, "%Y") == "2024")

customer_types <- customer_types %>%
  filter(Savivaldybe %in% df$Savivaldybe)

customer_types_by_population <- customer_types %>% left_join(population, by = "Savivaldybe")

customer_types_by_population <- customer_types_by_population %>% mutate(customers_per_person = kiekis / populiacija)

commercial_matrix <- customer_types_by_population %>%
  filter(Sutarties_tipas == "Komercinė") %>%
  dplyr::select(date, Savivaldybe, customers_per_person) %>%
  dplyr::arrange(date, Savivaldybe) %>%
  tidyr::pivot_wider(names_from = Savivaldybe, values_from = customers_per_person) %>%
  dplyr::arrange(date) %>%
  dplyr::select(-date) %>%
  as.matrix()

residential_matrix <- customer_types_by_population %>%
  filter(Sutarties_tipas == "Buitinė") %>%
  dplyr::select(date, Savivaldybe, customers_per_person) %>%
  dplyr::arrange(date, Savivaldybe) %>%
  tidyr::pivot_wider(names_from = Savivaldybe, values_from = customers_per_person) %>%
  dplyr::arrange(date) %>%
  dplyr::select(-date) %>%
  as.matrix()

unique_dates <- unique(customer_types_by_population$date)
unique_dates <- sort(unique_dates)
months <- seq(from = 1, to = length(unique_dates), by = 1)

# create fd objects
fd_obj_commercial <- smooth.basis(argvals = months, y = commercial_matrix, fdParobj = fdPar(basis, 2))$fd
fd_obj_residential <- smooth.basis(argvals = months, y = residential_matrix, fdParobj = fdPar(basis, 2))$fd

plot(fd_obj_commercial, main = "Commercial customers per person by municipality")
plot(fd_obj_residential, main = "Residential customers per person by municipality")

commercial_smoothed <- eval.fd(eval_points, fd_obj_commercial)
residential_smoothed <- eval.fd(eval_points, fd_obj_residential)

# transpose
commercial_smoothed_t <- t(commercial_smoothed)
residential_smoothed_t <- t(residential_smoothed)

df$commercial_customers <- commercial_smoothed_t
df$residential_customers <- residential_smoothed_t

colnames(df$commercial_customers) <- colnames(df$consumption)
colnames(df$residential_customers) <- colnames(df$consumption)

```

# Functional-on-scalar regression with mean wages, unemployment and customer count values

```{r}
# standardizing wages
df$atlyginimas_standardized <- (df$atlyginimas - mean(df$atlyginimas)) / sd(df$atlyginimas)

unempl_ordered <- population %>%
  arrange(factor(Savivaldybe, levels = municipalities)) %>%
  pull(vid_nedarbas)

df$vid_nedarbas <- as.numeric(unempl_ordered)

vid_nedarbas_std <- (df$vid_nedarbas - mean(df$vid_nedarbas)) / sd(df$vid_nedarbas)

df$vid_nedarbas_std <- as.numeric(vid_nedarbas_std)

commercial_vals <- eval.fd(months, fd_obj_commercial)
residential_vals <- eval.fd(months, fd_obj_residential)

commercial_avg <- colMeans(commercial_vals, na.rm = TRUE)
residential_avg <- colMeans(residential_vals, na.rm = TRUE)

commercial_avg_std <- (commercial_avg - mean(commercial_avg)) / sd(commercial_avg)
residential_avg_std <- (residential_avg - mean(residential_avg)) / sd(residential_avg)

df$commercial_avg <- commercial_avg
df$residential_avg <- residential_avg
df$commercial_avg_std <- commercial_avg_std
df$residential_avg_std <- residential_avg_std

# penalized flexible functional regression
fosr.fit <- pffr(consumption ~ atlyginimas_standardized, data = df)
summary(fosr.fit)
plot(fosr.fit, pages=1, scale=0) # coefficients of regressors over time

fosr.fit2 <- pffr(consumption ~ commercial_avg_std + atlyginimas_standardized, data = df)
summary(fosr.fit2)
plot(fosr.fit2, pages=1, scale=0)

fosr.fit3 <- pffr(consumption ~ commercial_avg_std + residential_avg_std + atlyginimas_standardized,  data = df)
summary(fosr.fit3)
plot(fosr.fit3, pages=1, scale=0)

fosr.fit4 <- pffr(consumption ~ commercial_avg_std + residential_avg_std + vid_nedarbas_std + atlyginimas_standardized,  data = df)
summary(fosr.fit4)
plot(fosr.fit4, pages=1, scale=0)

```

```{r}
# get predictions and transpose to match observed format
get_pffr_predictions <- function(model) {
  return(t(predict(model)))
}

pred_wages_only <- get_pffr_predictions(fosr.fit)
pred_wages_commercial <- get_pffr_predictions(fosr.fit2)
pred_comm_res_wages <- get_pffr_predictions(fosr.fit3)
pred_all_vars <- get_pffr_predictions(fosr.fit4)

observed <- t(as.matrix(df$consumption))

calculate_r2 <- function(observed, predicted) {
  sse <- sum((observed - predicted)^2)
  sst <- sum((observed - mean(observed))^2)
  return(1 - sse/sst)
}

# performance metrics
metrics <- data.frame(
  Model = c("Wages_Only", "Wages_Commercial", "Wages_Comm_Res", "All_Variables"),
  AIC = c(AIC(fosr.fit), AIC(fosr.fit2), AIC(fosr.fit3), AIC(fosr.fit4)),
  BIC = c(BIC(fosr.fit), BIC(fosr.fit2), BIC(fosr.fit3), BIC(fosr.fit4)),
  R2 = c(
    calculate_r2(as.vector(observed), as.vector(pred_wages_only)),
    calculate_r2(as.vector(observed), as.vector(pred_wages_commercial)),
    calculate_r2(as.vector(observed), as.vector(pred_comm_res_wages)),
    calculate_r2(as.vector(observed), as.vector(pred_all_vars))
  )
)

print(metrics)
```

```{r}
# Importance of each predictor from fosr.fit4 model
fosr_coefs <- coef(fosr.fit4)

commercial_coef_fosr <- abs(fosr_coefs$smterms$`commercial_avg_std(yindex)`$value)
residential_coef_fosr <- abs(fosr_coefs$smterms$`residential_avg_std(yindex)`$value)
unemployment_coef_fosr <- abs(fosr_coefs$smterms$`vid_nedarbas_std(yindex)`$value)
wages_coef_fosr <- abs(fosr_coefs$smterms$`atlyginimas_standardized(yindex)`$value)

total_effect_fosr <- commercial_coef_fosr + residential_coef_fosr + 
                     unemployment_coef_fosr + wages_coef_fosr

commercial_importance_fosr <- commercial_coef_fosr / total_effect_fosr * 100
residential_importance_fosr <- residential_coef_fosr / total_effect_fosr * 100
unemployment_importance_fosr <- unemployment_coef_fosr / total_effect_fosr * 100
wages_importance_fosr <- wages_coef_fosr / total_effect_fosr * 100

cat(sprintf("Mean importance from function-on-scalar model:\n"))
cat(sprintf("Mean importance of the count of commercial customers per person: %.2f%%\n", 
           mean(commercial_importance_fosr)))
cat(sprintf("Mean importance of the count of residential customers per person: %.2f%%\n", 
           mean(residential_importance_fosr)))
cat(sprintf("Mean importance of unemployment: %.2f%%\n", 
           mean(unemployment_importance_fosr)))
cat(sprintf("Mean importance of wages: %.2f%%\n", 
           mean(wages_importance_fosr)))

eval_points <- 1:length(commercial_coef_fosr)
month_positions <- seq(1, length(eval_points), length.out = 12)

plot(eval_points, commercial_importance_fosr, type="l", lwd=2, col="black",
     xlab="Month", ylab="Relative importance (%)", 
     main="Relative importance of predictors over time (function-on-scalar)",
     ylim=c(0, max(commercial_importance_fosr, residential_importance_fosr, 
                  unemployment_importance_fosr, wages_importance_fosr) * 1.5),
     xaxt="n")
axis(1, at=month_positions, labels=month.abb)
lines(eval_points, residential_importance_fosr, lwd=2, col="red", lty=1)
lines(eval_points, unemployment_importance_fosr, lwd=2, col="blue", lty=1)
lines(eval_points, wages_importance_fosr, lwd=2, col="darkgreen", lty=1)
grid(NULL, NULL, lty=3, col="lightgray")
legend("topright", 
       legend=c("Commercial Customers", "Residential Customers", "Unemployment", "Wages"), 
       lty=1, 
       col=c("black", "red", "blue", "darkgreen"),
       bty="n")

```




## Function-on-function regression model: unemployment (function), commercial/residential customer count per person (function), and wages (scalar)

### Predictor standardization

```{r}
eval_points <- seq(min(months), max(months), length.out = 100)

# sunction to standardize a functional data object - each month is individually transformed to have mean 0 and standard deviation 1
standardize_fd <- function(fd_obj) {
  eval_points <- seq(min(months), max(months), length.out = 100)
  fd_values <- eval.fd(eval_points, fd_obj)
  
  means <- rowMeans(fd_values)
  sds <- apply(fd_values, 1, sd)
  
  fd_values_std <- sweep(fd_values, 1, means, "-")
  fd_values_std <- sweep(fd_values_std, 1, sds, "/")
  
  fd_basis <- fd_obj$basis
  fd_std <- Data2fd(argvals = eval_points, y = fd_values_std, basisobj = fd_basis)
  
  return(fd_std)
}

commercial_fd_std <- standardize_fd(fd_obj_commercial)
residential_fd_std <- standardize_fd(fd_obj_residential)
unemployment_fd_std <- standardize_fd(fd_obj_all_mun_unempl)

```

```{r}
# velocity for unemployment
unemployment_fd_vel <- deriv.fd(unemployment_fd_std, 1)

par(mfrow=c(1,2))
plot(unemployment_fd_std, main="Unemployment", xlab="Month")
plot(unemployment_fd_vel, main="Unemployment Velocity", xlab="Month")
par(mfrow=c(1,1))

unemployment_vel_values <- eval.fd(eval_points, unemployment_fd_vel)

unemployment_vel_std_values <- (unemployment_vel_values - mean(unemployment_vel_values)) / sd(as.vector(unemployment_vel_values))
unemployment_vel_std <- Data2fd(argvals = eval_points, 
                              y = unemployment_vel_std_values, 
                              basisobj = unemployment_fd_vel$basis)

xfdlist <- list(
  const = rep(1, nrow(df)),
  commercial = commercial_fd_std,
  residential = residential_fd_std, 
  unemployment = unemployment_fd_std,
  unemployment_vel = unemployment_vel_std,
  wages = df$atlyginimas_standardized
)
```


### Parameter optimization

```{r}
# # non-startdartized fds:
# xfdlist <- list(
#   const = rep(1, nrow(df)),
#   commercial = fd_obj_commercial,
#   residential = fd_obj_residential,
#   unemployment = fd_obj_all_mun_unempl,
#   wages = df$atlyginimas
# )

# find optimal parameters for a specific regressor
find_optimal_params <- function(regressor_name) {
  cat("\nFinding optimal parameters for:", regressor_name, "\n")
  
  nbasis_values <- seq(8, 24, 1)
  lambda_log_range <- seq(-5, 1, 1)
  n_nbasis <- length(nbasis_values)
  n_lambda <- length(lambda_log_range)
  
  # array to store GCV values
  smoothStats <- array(NA, dim=c(n_nbasis, n_lambda),
                      dimnames=list(nbasis_values, lambda_log_range))
  
  for (i in 1:n_nbasis) {
    nbasis <- nbasis_values[i]
    beta_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = nbasis)
    
    for (j in 1:n_lambda) {
      lambda <- 10^lambda_log_range[j]
      betafdPar <- fdPar(beta_basis, 2, lambda = lambda)
      
      default_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = 15)
      default_betafdPar <- fdPar(default_basis, 2, lambda = 1)
      
      betalist <- list(
        const = default_betafdPar,
        commercial = default_betafdPar,
        residential = default_betafdPar,
        unemployment = default_betafdPar,
        unemployment_vel = unemployment_vel_std,
        wages = default_betafdPar
      )
      betalist[[regressor_name]] <- betafdPar
      
      # fit model and calculate GCV
      tryCatch({
        model <- fRegress(consumption_fd, xfdlist, betalist)
        
        y_hat_matrix <- eval.fd(eval_points, model$yhatfd)
        y_matrix <- eval.fd(eval_points, consumption_fd)
        residuals <- y_matrix - y_hat_matrix
        RSS <- sum(residuals^2)
        df <- sum(diag(model$hatmat))
        n <- length(as.vector(y_matrix))
        GCV <- RSS / (n * (1 - df/n)^2)
        
        smoothStats[i, j] <- GCV
        
        if ((i %% 5 == 0) && (j %% 3 == 0)) {
          cat("  Completed nbasis =", nbasis, ", lambda =", lambda, ", GCV =", GCV, "\n")
        }
      }, error = function(e) {
        cat("  Error with nbasis =", nbasis, ", lambda =", lambda, ":", conditionMessage(e), "\n")
      })
    }
  }
  
  # minimum GCV
  min_idx <- which(smoothStats == min(smoothStats, na.rm = TRUE), arr.ind = TRUE)
  best_nbasis <- as.numeric(rownames(smoothStats)[min_idx[1]])
  best_log_lambda <- as.numeric(colnames(smoothStats)[min_idx[2]])
  best_lambda <- 10^best_log_lambda
  best_gcv <- smoothStats[min_idx]
  
  cat("\nBest parameters for", regressor_name, ":\n")
  cat("nbasis =", best_nbasis, "\n")
  cat("lambda =", best_lambda, "\n")
  cat("GCV =", best_gcv, "\n")
  
  return(list(
    nbasis = best_nbasis,
    lambda = best_lambda,
    log_lambda = best_log_lambda,
    gcv = best_gcv
  ))
}

const_params <- find_optimal_params("const")
commercial_params <- find_optimal_params("commercial")
residential_params <- find_optimal_params("residential")
unemployment_params <- find_optimal_params("unemployment")
unemployment_vel_params <- find_optimal_params("unemployment_vel")
wages_params <- find_optimal_params("wages")

# basis and parameter objects for each regressor
const_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = const_params$nbasis)
commercial_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = commercial_params$nbasis)
residential_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = residential_params$nbasis)
unemployment_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = unemployment_params$nbasis)
unemployment_vel_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = unemployment_vel_params$nbasis)
wages_basis <- create.bspline.basis(rangeval = range(eval_points), nbasis = wages_params$nbasis)

const_betafdPar <- fdPar(const_basis, 2, lambda = const_params$lambda)
commercial_betafdPar <- fdPar(commercial_basis, 2, lambda = commercial_params$lambda)
residential_betafdPar <- fdPar(residential_basis, 2, lambda = residential_params$lambda)
unemployment_betafdPar <- fdPar(unemployment_basis, 2, lambda = unemployment_params$lambda)
unemployment_vel_betafdPar <- fdPar(unemployment_basis, 2, lambda = unemployment_vel_params$lambda)
wages_betafdPar <- fdPar(wages_basis, 2, lambda = wages_params$lambda)

```



```{r}
# functional predictors
betalist <- list(
  const = const_betafdPar,
  commercial = commercial_betafdPar,
  residential = residential_betafdPar,
  unemployment = unemployment_betafdPar,
  unemployment_vel = unemployment_vel_std,
  wages = wages_betafdPar
)

# function-on-function regression
fof_model <- fRegress(consumption_fd, xfdlist, betalist)

betaestlist <- fof_model$betaestlist

month_positions <- seq(min(eval_points), max(eval_points), length.out=12)

par(mfrow=c(2,3))

# plot intercept function
plot(betaestlist$const$fd, main="Baseline consumption",
     xlab="Month", ylab="Consumption (kWh/person)",
     xaxt="n")
axis(1, at=month_positions)

# plot commercial customers effect function
plot(betaestlist$commercial$fd, 
     main="Effect of commercial customers",
     xlab="Month", ylab="Effect magnitude",
     xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty=2)

# plot residential customers effect function
plot(betaestlist$residential$fd, 
     main="Effect of residential customers", 
     xlab="Month", ylab="Effect magnitude",
     xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty=2)

# plot unemployment velocity effect function
plot(betaestlist$unemployment$fd, 
     main="Effect of unemployment", 
     xlab="Month", ylab="Effect magnitude",
     xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty=2)

# plot unemployment velocity effect function
plot(betaestlist$unemployment_vel$fd, 
     main="Effect of unemployment velocity", 
     xlab="Month", ylab="Effect magnitude",
     xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty=2)

# plot wages effect function
plot(betaestlist$wages$fd, 
     main="Effect of wages", 
     xlab="Month", ylab="Effect magnitude",
     xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty=2)

par(mfrow=c(1,1))
intercept_curve <- predict(betaestlist$const$fd, eval_points)
consumption_mean <- predict(mean.fd(consumption_fd), eval_points)

# intercept and mean consumption plot (overlap due to regressor standardization)
ylim1 <- range(consumption_mean, intercept_curve)

plot(eval_points, intercept_curve, ylim=ylim1, lwd=2,
     main="Intercept, mean consumption", type='l',
     xlab='', ylab='kWh per person', xaxt="n")
axis(1, at=month_positions)
lines(eval_points, consumption_mean, lty='dashed')
abline(h=0, lty='dashed')
legend("topright", legend=c("Intercept", "Mean"),
       lty=c(1,2), col=c("black", "black"))

commercial_coef <- predict(betaestlist$commercial$fd, eval_points)
residential_coef <- predict(betaestlist$residential$fd, eval_points)
unemployment_coef <- predict(betaestlist$unemployment$fd, eval_points)
unemployment_vel_coef <- predict(betaestlist$unemployment_vel$fd, eval_points)
wages_coef <- predict(betaestlist$wages$fd, eval_points)

consumption_hat <- fof_model$yhatfd
consumption_hat_matrix <- eval.fd(eval_points, consumption_hat)
consumption_matrix <- eval.fd(eval_points, consumption_fd)
consumption_mean_matrix <- eval.fd(eval_points, mean.fd(consumption_fd))

# residuals
resmat <- consumption_matrix - consumption_hat_matrix
ncurve <- ncol(consumption_matrix)
resmat0 <- consumption_matrix - consumption_mean_matrix %*% matrix(1,1,ncurve)

# R-squared at each time point
SSE0 <- apply(resmat0^2, 1, sum)
SSE1 <- apply(resmat^2, 1, sum)
R2_by_time <- (SSE0-SSE1)/SSE0

ylim2 <- c(min(0, min(commercial_coef), min(residential_coef), min(unemployment_coef), min(unemployment_vel_coef)), 
           max(commercial_coef, residential_coef, R2_by_time, unemployment_coef, unemployment_vel_coef, wages_coef, 130))
plot(eval_points, commercial_coef, lwd=2, xlab='', ylab='', ylim=ylim2, type='l',
     main='Effects', xaxt="n")
axis(1, at=month_positions)
abline(h=0, lty='dashed')
lines(eval_points, residential_coef, lty=1, col="red")
lines(eval_points, unemployment_vel_coef, lty=1, col="blue")
lines(eval_points, unemployment_coef, lty=1, col="darkgreen")
lines(eval_points, wages_coef, lty=1, col="orange")
legend("topleft", 
       legend=c("Commercial effect", "Residential effect", "Unemployment effect", "Unemployment velocity effect", "Wages efect"), 
       lty=1, col=c("black", "red", "blue", "darkgreen", "orange"))

op <- par(mfrow=c(1,1))
ylim_r2 <- c(0, max(R2_by_time) * 1.1)
plot(eval_points, R2_by_time, lwd=2, xlab='Month', ylab='R-squared', 
     type='l', col="blue", main='Model fit (R-squared) by month', 
     ylim=ylim_r2, xaxt="n")
axis(1, at=month_positions)
par(op)

y2cMap <- smooth.basis(eval_points, t(as.matrix(df$consumption)), fdPar(consumption_basis))$y2cMap
SigmaE <- cov(t(resmat))

# standard errors
fRegressList1 <- fRegress(consumption_fd, xfdlist, betalist, y2cMap=y2cMap, SigmaE=SigmaE)
fRegressList2 <- fRegress.stderr(fRegressList1, y2cMap, SigmaE)
betastderrlist <- fRegressList2$betastderrlist

# coefficients with confidence intervals
par(mfrow=c(2,3))
plotbeta(betaestlist, betastderrlist, eval_points)
# regression function 1 - the intercept function with confidence intervals, baseline electricity consumption pattern across months when the effect of all predictors are zero
# regression function 2-6 - coefficient functions for each regressor, showing how the effect of this predictor varies across the year (with confidence intervals):
  # commercial,
  # residential,
  # unemployment,
  # unemployment_vel,
  # wages
# for a coefficient to be statistically significant at a given point in time, the confidence interval must not include zero. Based on this:
# Intercept and wages are statistically significant throughout the year

# calculate R-squared
calculate_r2 <- function(model) {
  yhat <- eval.fd(eval_points, model$yhatfd)
  y <- eval.fd(eval_points, consumption_fd)
  SSE <- sum((y - yhat)^2)
  SST <- sum((y - mean(y))^2)
  R2 <- 1 - SSE/SST
  return(R2)
}

# R-squared
r2_optimized <- calculate_r2(fof_model)

cat(sprintf("R-squared:  %.4f\n", r2_optimized))

```

```{r}
# relative importance of each predictor by month
total_effect <- abs(commercial_coef) + abs(residential_coef) + abs(unemployment_coef) + abs(unemployment_vel_coef) + abs(wages_coef)
commercial_importance <- abs(commercial_coef) / total_effect * 100
residential_importance <- abs(residential_coef) / total_effect * 100
unemployment_vel_importance <- abs(unemployment_vel_coef) / total_effect * 100
unemployment_importance <- abs(unemployment_coef) / total_effect * 100
wages_importance <- abs(wages_coef) / total_effect * 100

plot(eval_points, commercial_importance, type="l", lwd=2, col="black",
     xlab="Month", ylab="Relative importance (%)", 
     main="Relative importance of predictors over time (function-on-function)",
     ylim=c(0, max(commercial_importance, residential_importance, unemployment_importance, unemployment_vel_importance, wages_importance) * 1.5),
     xaxt="n")
axis(1, at=month_positions, labels=month.abb)
lines(eval_points, residential_importance, lwd=2, col="red", lty=1)
lines(eval_points, unemployment_vel_importance, lwd=2, col="blue", lty=1)
lines(eval_points, unemployment_importance, lwd=2, col="darkgreen", lty=1)
lines(eval_points, wages_importance, lwd=2, col="orange", lty=1)
grid(NULL, NULL, lty=3, col="lightgray")

legend("topright", 
       legend=c("Commercial Customers", "Residential Customers", "Unemployment", "Unemployment velocity", "Wages"), 
       lty=1, 
       col=c("black", "red", "blue", "darkgreen", "orange"),
       bty="n")

cat(sprintf("Mean importance of the count of commercial customers per person: %.2f%%\n", mean(commercial_importance)))
cat(sprintf("Mean importance of the count of residential customers per person: %.2f%%\n", mean(residential_importance)))
cat(sprintf("Mean importance of unemployment: %.2f%%\n", mean(unemployment_importance)))
cat(sprintf("Mean importance of unemployment velocity: %.2f%%\n", mean(unemployment_vel_importance)))
cat(sprintf("Mean importance of wages: %.2f%%\n", mean(wages_importance)))

```
